# 数据结构

### 学前须知
1.为什么要学习数据结构与算法
2.编程语言的选择
3.课程大纲
4.注意事项
5.课程的选择

### 01.复杂度✍

 01.开发环境搭建
 02.斐波那契数
 03.算法的评估
 04.时间复杂度的估算
 05.大O表达法
 06.斐波那契数复杂度分析
 07.leetcode

### 02.数组✍

 02.动态数组
 01.线性表
 02.接口设计
 03.简单接口的实现
 04.clear
 05.补充
 06.add
 07.打印
 08.remove
 09.add_index
 10.接口测试
 11.动态扩容
 12.泛型
 13.对象数组
 14.clear_细节
 15.remove_细节
 16.equals
 17.null值处理
 18.ArrayList源码发分析
 19.答疑
 20.补充

### 03.链表✍

 01.简介
 02.接口设计
 03.clear
 04.add
 05.remove
 06.indexOf_toString
 07.练习01-删除节点
 08.练习02-反转链表01-递归
 09.练习02-反转链表02-迭代
 10.练习03-环形链表
 11.答疑
 12.补充
 13.虚拟头结点
 14.复杂度分析01-ArrayList
 15.复杂度分析02-LinkedList
 16.均摊复杂度
 17.ArrayList的缩容
 18.复杂度震荡
 19.双向链表01-简介
 20.双向链表02-clear
 21.双向链表03-add
 22.双向链表04-remove
 23.双向链表05-接口测试
 24.双向链表06-总结
 25.双向链表07-源码分析
 26.单向循环链表01-add
 27.单向循环链表02-remove
 28.单向循环链表03-接口测试_修复BUG
 29.双向循环链表01-add
 30.双向循环链表02-remove
 31.双向循环链表03-练习-约瑟夫问题
 32.静态链表
 33.ArrayList的优化思路

### 04.栈✍

 01.设计与实现

 02.应用举例

 03.练习-有效的括号01

 04.练习-有效的括号02

 05.练习-有效的括号03

 06.补充

### 05.队列✍

 01.设计和实现

 02.练习-用栈实现队列

 03.Queue源码分析

 04.双端队列

 05.循环队列01-实现

 06.循环队列02-测试-动态扩容

 07.循环队列03-索引映射封装

 08.循环双端队列01-实现

 09.循环双端队列02-测试

 10.循环双端队列03-模运算优化

 11.clear

### 06.二叉树👌

01.树

02.二叉树及其性质

03.真二叉树_满二叉树

04.完全二叉树01-概念

05.完全二叉树02-性质01

06.完全二叉树03-性质02

07.完全二叉树04-面试题

08.完全二叉树05-公式总结

09.国外教材

### 07.二叉搜索树👌

01.需求分析

02.概念-接口设计

03.and01-根节点

04.and01-思路

05.and01-实现

06.compare01-comprable

07.compare02-comparator

08.compare03-完美结合

09.compare04-匿名类

10.打印器01-使用

11.打印器02-Person

12.打印器03-更多用法

13.打印器04-文件-建议

14.网站推荐

15.值相等的处理

16.前序遍历

17.中序遍历

18.后续遍历

19.层序遍历

20.设计遍历接口

21.曾强遍历接口01

22.增加遍历接口02

23.树状打印二叉树

24.练习01-计算二叉树的而高度

25.练习02-完全二叉树的判断01

26.练习02-完全二叉树的判断02

27.练习03-翻转二叉树

28.重构二叉树

29.前驱节点

30.后继节点

31.remove01-度为0的节点

32.remove02-度为2的节点

33.remove03-实现

34.测试_完善接口

35.重构代码

36.答疑

37.补充

### 08.AVL树✍

01.二叉搜索树复杂度分析

02.平衡二叉搜索树
03.基本概念
04.添加导致的平衡
05.旋转01-LL_RR
06.旋转02-LR_RL
07.旋转03-总结
08.afterAdd
09.计算平衡因子
10.更新高度
11.恢复平衡
12.旋转方向的判断
13.补充
14.左旋转的实现
15.右旋转的实现
16.示例
17.统一旋转操作01
18.统一旋转操作02
19.删除导致的失衡
20.删除后的平衡方案
21.afterRemove
22.总结
23.补充

### 09.B树✍

01.初识红黑树

02.初识B树

03.性质

04.B树_二叉树索树

05.添加

06.上溢的解决

07.删除

08.下溢的解决

09.4阶B树

10.补充

### 10.红黑树✍

 01.错误的示范

 02.与4阶B树的等价变换

 03.辅助函数

 04.添加01

 05.添加02-情况分析

 06.添加03-black_uncle01_LL_RR

 07.添加04-black_uncle02_LR_RL

 08.添加05-red_uncle

 09.添加06-情况总结

 10.添加07-实现01-red_uncle

 11.添加08-实现02-back_uncle

 12.添加09-测试

 13.添加10-补充

 14.删除01-情况分析

 15.删除02-red_replacement01_分析

 16.删除03-red_replacement02_实现

 17.删除04-black_leaf01-根节点

 18.删除05-black_leaf02-black_sibling01

 19.删除06-black_leaf03-black_sibling02

 20.删除07-black_leaf04-red_sibling

 21.删除08-总结

 22.删除09-black_leaf05-实现01-red_sibling

 23.删除10-black_leaf06-实现01-black_sibling

 24.删除11-black_leaf07-对称处理

 25.删除12-测试

 26.删除13-quchureplacement参数

 27.答疑

 28.总结

 29.平衡

 30.性能对比

### 11.集合✍

 01.简介
 02.ListSet
 03.TreeSet
 04.复杂度分析
 05.性能对比
 06.TreeSet的局限性

### 12.映射✍

 01.简介
 02.Node
 03.put
 04.get_remove
 05.contains
 06.traversal
 07.测试
 08.利用TreeMap实现TreeSet
 09.TreeMap_TreeSet源码分析
 10.补充
 11.代码量与性能

### 13.哈希表✍

 01.TreeMap复杂度分析
 02.初识哈希表
 03.哈希冲突
 04.JDK8的哈希冲突解决
 05.哈希函数
 06.哈希值计算01-int_float
 07.哈希值计算02-long_double
 08.哈希值计算03-字符串01
 09.哈希值计算04-字符串02
 10.哈希值计算05-总结
 11.哈希值计算06-自定义对象
 12.equals
 13.同时实现hashCode_equals
 14.不实现hashCode_equals
 15.只实现equals
 16.只实现hashCode
 17.答疑
 18.补充
 19.clear
 20.put
 21.compare01-基本处理
 22.compare02-其他情况
 23.compare03-分析测试
 24.get_containsKey
 25.remove
 26.containsValue_traversal
 27.发现问题
 28.打印红黑树
 29.分析问题
 30.回顾问题
 31.重写node01
 32.重写node02
 33.重写put01
 34.重写put02
 35.put优化
 36.node优化
 37.compareTo调整
 38.测试用例01
 39.测试用例02
 40.HashMap源码预览
 41.测试用例03
 42.bug修复
 43.代码演化01-简化put和node
 44.代码演化02-完善优化put和model
 45.代码演化03-增加comparable
 46.代码演化04-最后的比较策略
 47.ndoe的hash值调整
 48.扩容01-填装因子
 49.扩容02-思路
 50.扩容03-实现
 51.扩容04-测试
 52.equals的规范
 53.TreeMap_HashMap
 54.去模运算_素数
 55.答疑
 56.LinkedHashMap01-创建节点
 57.LinkedHashMap02-串线_清空_遍历
 58.LinkedHashMap03-删除节点
 59.LinkedHashMap04-删除的bug
 60.LinkedHashMap05-修复bug
 61.HashSet_LinkedHashSet
 62.答疑
 63.LinkedHashMap_HashMap源码分析


### 14.二叉堆✍

 01.需求分析
 02.堆
 03.二叉堆
 04.基本接口的实现
 05.add01-思路
 06-add02-实现
 07.打印调试
 08.优化
 09.抽取父类
 10.remove01-思路
 11.remove02-实现
 12.replace
 13.heapify01-自下而上的上滤
 14.heapify02-自下而上的下滤
 15.heapify03-效率对比
 16.heapify04-复杂度计算
 17.heapify05-答疑 
 18.heapify05-实现
 19.小顶堆
 20.Top面试题

### 15.优先级队列👌

 01.实现
 02.PriorityQueue源码分析

### 16.哈夫曼树👌

 01.需求分析

 02.构建哈夫曼树

 03.构建哈夫曼编码

### 17.Trie

 01.简介

 02.接口设计

 03.Node设计

 04.clear_get_contains

 05.add

 06.startsWith

 07.代码调整

 08.remove

 09.总结_bug修复

### 18.补充

 01.总结

 02.zig_zag_满二叉树_完全二叉树

 03.四则运算_表达式树

 04.非递归前序遍历01_思路

 05.非递归前序遍历02_实现

 06.非递归中序遍历

 07.非递归后续遍历01

 08.非递归后续遍历02

 09.非递归前序遍历的另一种思路

 10.答疑

