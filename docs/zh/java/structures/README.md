# 大纲

### 学前须知

1. 为什么要学习数据结构与算法
2. 编程语言的选择
3. 课程大纲
4. 注意事项
5. 课程的选择

### 01.复杂度

  1. 开发环境搭建
  2. 斐波那契数
  3. 算法的评估
  4. 时间复杂度的估算
  5. 大O表达法
  6. 斐波那契数复杂度分析
  7. leetcode

### 02.数组

  2. 动态数组
  3. 线性表
  4. 接口设计
  5. 简单接口的实现
  6. clear
  7. 补充
  8. add
  9. 打印
  10. remove
  11. add_index
  12. 接口测试
  13. 动态扩容
  14. 泛型
  15. 对象数组
  16. clear_细节
  17. remove_细节
  18. equals
  19. null值处理
  20. ArrayList源码发分析
  21. 答疑
  22. 补充

### 03.链表

  1. 简介
  2. 接口设计
  3. clear
  4. add
  5. remove
  6. indexOf_toString
  7. 练习01-删除节点
  8. 练习02-反转链表01-递归
  9. 练习02-反转链表02-迭代
  10. 练习03-环形链表
  11. 答疑
  12. 补充
  13. 虚拟头结点
  14. 复杂度分析01-ArrayList
  15. 复杂度分析02-LinkedList
  16. 均摊复杂度
  17. ArrayList的缩容
  18. 复杂度震荡
  19. 双向链表01-简介
  20. 双向链表02-clear
  21. 双向链表03-add
  22. 双向链表04-remove
  23. 双向链表05-接口测试
  24. 双向链表06-总结
  25. 双向链表07-源码分析
  26. 单向循环链表01-add
  27. 单向循环链表02-remove
  28. 单向循环链表03-接口测试_修复BUG
  29. 双向循环链表01-add
  30. 双向循环链表02-remove
  31. 双向循环链表03-练习-约瑟夫问题
  32. 静态链表
  33. ArrayList的优化思路

### 04.栈

  1. 设计与实现
  2. 应用举例
  3. 练习-有效的括号01
  4. 练习-有效的括号02
  5. 练习-有效的括号03
  6. 补充

### 05.队列

  1. 设计和实现
  2. 练习-用栈实现队列
  3. Queue源码分析
  4. 双端队列
  5. 循环队列01-实现
  6. 循环队列02-测试-动态扩容
  7. 循环队列03-索引映射封装
  8. 循环双端队列01-实现
  9. 循环双端队列02-测试
  10. 循环双端队列03-模运算优化
  11. clear

### 06.二叉树

01.树

2. 二叉树及其性质
3. 真二叉树_满二叉树
4. 完全二叉树01-概念
5. 完全二叉树02-性质01
6. 完全二叉树03-性质02
7. 完全二叉树04-面试题
8. 完全二叉树05-公式总结
9. 国外教材

### 07.二叉搜索树

1. 需求分析
2. 概念-接口设计
3. and01-根节点
4. and01-思路
5. and01-实现
6. compare01-comprable
7. compare02-comparator
8. compare03-完美结合
9. compare04-匿名类
10. 打印器01-使用
11. 打印器02-Person
12. 打印器03-更多用法
13. 打印器04-文件-建议
14. 网站推荐
15. 值相等的处理
16. 前序遍历
17. 中序遍历
18. 后续遍历
19. 层序遍历
20. 设计遍历接口
21. 曾强遍历接口01
22. 增加遍历接口02
23. 树状打印二叉树
24. 练习01-计算二叉树的而高度
25. 练习02-完全二叉树的判断01
26. 练习02-完全二叉树的判断02
27. 练习03-翻转二叉树
28. 重构二叉树
29. 前驱节点
30. 后继节点
31. remove01-度为0的节点
32. remove02-度为2的节点
33. remove03-实现
34. 测试_完善接口
35. 重构代码
36. 答疑
37. 补充

### 08.AVL树

1. 二叉搜索树复杂度分析
2. 平衡二叉搜索树
3. 基本概念
4. 添加导致的平衡
5. 旋转01-LL_RR
6. 旋转02-LR_RL
7. 旋转03-总结
8. afterAdd
9. 计算平衡因子
10. 更新高度
11. 恢复平衡
12. 旋转方向的判断
13. 补充
14. 左旋转的实现
15. 右旋转的实现
16. 示例
17. 统一旋转操作01
18. 统一旋转操作02
19. 删除导致的失衡
20. 删除后的平衡方案
21. afterRemove
22. 总结
23. 补充

### 09.B树

1. 初识红黑树
2. 初识B树
3. 性质
4. B树_二叉树索树
5. 添加
6. 上溢的解决
7. 删除
8. 下溢的解决
9. 4阶B树
10. 补充

### 10.红黑树

  1. 错误的示范
  2. 与4阶B树的等价变换
  3. 辅助函数
  4. 添加01
  5. 添加02-情况分析
  6. 添加03-black_uncle01_LL_RR
  7. 添加04-black_uncle02_LR_RL
  8. 添加05-red_uncle
  9. 添加06-情况总结
  10. 添加07-实现01-red_uncle
  11. 添加08-实现02-back_uncle
  12. 添加09-测试
  13. 添加10-补充
  14. 删除01-情况分析
  15. 删除02-red_replacement01_分析
  16. 删除03-red_replacement02_实现
  17. 删除04-black_leaf01-根节点
  18. 删除05-black_leaf02-black_sibling01
  19. 删除06-black_leaf03-black_sibling02
  20. 删除07-black_leaf04-red_sibling
  21. 删除08-总结
  22. 删除09-black_leaf05-实现01-red_sibling
  23. 删除10-black_leaf06-实现01-black_sibling
  24. 删除11-black_leaf07-对称处理
  25. 删除12-测试
  26. 删除13-quchureplacement参数
  27. 答疑
  28. 总结
  29. 平衡
  30. 性能对比

### 11.集合

  1. 简介
  2. ListSet
  3. TreeSet
  4. 复杂度分析
  5. 性能对比
  6. TreeSet的局限性

### 12.映射

  1. 简介
  2. Node
  3. put
  4. get_remove
  5. contains
  6. traversal
  7. 测试
  8. 利用TreeMap实现TreeSet
  9. TreeMap_TreeSet源码分析
  10. 补充
  11. 代码量与性能

### 13.哈希表

  1. TreeMap复杂度分析
  2. 初识哈希表
  3. 哈希冲突
  4. JDK8的哈希冲突解决
  5. 哈希函数
  6. 哈希值计算01-int_float
  7. 哈希值计算02-long_double
  8. 哈希值计算03-字符串01
  9. 哈希值计算04-字符串02
  10. 哈希值计算05-总结
  11. 哈希值计算06-自定义对象
  12. equals
  13. 同时实现hashCode_equals
  14. 不实现hashCode_equals
  15. 只实现equals
  16. 只实现hashCode
  17. 答疑
  18. 补充
  19. clear
  20. put
  21. compare01-基本处理
  22. compare02-其他情况
  23. compare03-分析测试
  24. get_containsKey
  25. remove
  26. containsValue_traversal
  27. 发现问题
  28. 打印红黑树
  29. 分析问题
  30. 回顾问题
  31. 重写node01
  32. 重写node02
  33. 重写put01
  34. 重写put02
  35. put优化
  36. node优化
  37. compareTo调整
  38. 测试用例01
  39. 测试用例02
  40. HashMap源码预览
  41. 测试用例03
  42. bug修复
  43. 代码演化01-简化put和node
  44. 代码演化02-完善优化put和model
  45. 代码演化03-增加comparable
  46. 代码演化04-最后的比较策略
  47. ndoe的hash值调整
  48. 扩容01-填装因子
  49. 扩容02-思路
  50. 扩容03-实现
  51. 扩容04-测试
  52. equals的规范
  53. TreeMap_HashMap
  54. 去模运算_素数
  55. 答疑
  56. LinkedHashMap01-创建节点
  57. LinkedHashMap02-串线_清空_遍历
  58. LinkedHashMap03-删除节点
  59. LinkedHashMap04-删除的bug
  60. LinkedHashMap05-修复bug
  61. HashSet_LinkedHashSet
  62. 答疑
  63. LinkedHashMap_HashMap源码分析


### 14.二叉堆

  1. 需求分析
  2. 堆
  3. 二叉堆
  4. 基本接口的实现
  5. add01-思路
  6. add02-实现
  7. 打印调试
  8. 优化
  9. 抽取父类
  10. remove01-思路
  11. remove02-实现
  12. replace
  13. heapify01-自下而上的上滤
  14. heapify02-自下而上的下滤
  15. heapify03-效率对比
  16. heapify04-复杂度计算
  17. heapify05-答疑 
  18. heapify05-实现
  19. 小顶堆
  20. Top面试题

### 15.优先级队列

  1. 实现
  2. PriorityQueue源码分析

### 16.哈夫曼树

  1. 需求分析
  2. 构建哈夫曼树
  3. 构建哈夫曼编码

### 17.Trie

  1. 简介
  2. 接口设计
  3. Node设计
  4. clear_get_contains
  5. add
  6. startsWith
  7. 代码调整
  8. remove
  9. 总结_bug修复

### 18.补充

  1. 总结
  2. zig_zag_满二叉树_完全二叉树
  3. 四则运算_表达式树
  4. 非递归前序遍历01_思路
  5. 非递归前序遍历02_实现
  6. 非递归中序遍历
  7. 非递归后续遍历01
  8. 非递归后续遍历02
  9. 非递归前序遍历的另一种思路
  10. 答疑

