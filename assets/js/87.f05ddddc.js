(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{434:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("h2",{attrs:{id:"链表的结构介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表的结构介绍"}},[t._v("#")]),t._v(" 链表的结构介绍")]),t._v(" "),s("h2",{attrs:{id:"linklist"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linklist"}},[t._v("#")]),t._v(" LinkList")]),t._v(" "),s("ul",[s("li",[t._v("LinkList的接口设计\n"),s("ul",[s("li",[t._v("将ArrayList和LinkList抽象为一个接口List；")]),t._v(" "),s("li",[t._v("将List需要实现的功能代码抽象为AbstractList")])])]),t._v(" "),s("li",[t._v("Clear")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v(" size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n firstNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("ul",[s("li",[t._v("add（int index,E element）")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Node")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("remove(int index)")]),t._v(" "),s("li",[t._v("indexOf(E element)")]),t._v(" "),s("li",[t._v("toString")]),t._v(" "),s("li",[t._v("练习，删除节点")]),t._v(" "),s("li",[t._v("网站：https://visualgo.net/zh")]),t._v(" "),s("li",[t._v("leecode做题类的建立")]),t._v(" "),s("li",[t._v("删除节点remove（Node e）")]),t._v(" "),s("li",[t._v("反转链表")]),t._v(" "),s("li",[t._v("循环链表")]),t._v(" "),s("li",[t._v("补充：\n"),s("ul",[s("li",[t._v("LinkList的remove和add要进行检查")]),t._v(" "),s("li",[t._v("环形指针快慢指针每次缩小1的差距，快指针走2步，慢指针走1步，这样是非常安全的；")]),t._v(" "),s("li")])])]),t._v(" "),s("h4",{attrs:{id:"虚拟头节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟头节点"}},[t._v("#")]),t._v(" 虚拟头节点")]),t._v(" "),s("p",[t._v("让代码更精简，优化LinkList")]),t._v(" "),s("h4",{attrs:{id:"分析arraylist和linklist的复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析arraylist和linklist的复杂度"}},[t._v("#")]),t._v(" 分析ArrayList和LinkList的复杂度")]),t._v(" "),s("ul",[s("li",[t._v("get")]),t._v(" "),s("li",[t._v("set")]),t._v(" "),s("li",[t._v("add")]),t._v(" "),s("li",[t._v("remove")])]),t._v(" "),s("h4",{attrs:{id:"均摊复杂度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#均摊复杂度"}},[t._v("#")]),t._v(" 均摊复杂度")]),t._v(" "),s("p",[t._v("链表的添加、删除的复杂度是O（1）是指添加和删除的那一刻，其实整体的复杂度还是O(N)\n但是链表的内存空间会有优势；")]),t._v(" "),s("h4",{attrs:{id:"动态数组arraylist的缩容操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态数组arraylist的缩容操作"}},[t._v("#")]),t._v(" 动态数组ArrayList的缩容操作")]),t._v(" "),s("p",[t._v("申请一块新的空间，然后复制数组中的数据\n剩余空间占总容量的一半时进行缩容，这里可以按照自己调整；\n缩容的最小值是defaultCapacity\n新建一个容器，将老的数据复制到新容器中。")]),t._v(" "),s("h4",{attrs:{id:"复杂度震荡"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂度震荡"}},[t._v("#")]),t._v(" 复杂度震荡")]),t._v(" "),s("p",[t._v("如果扩容倍数、缩容时机设计不得当，有可能会导致复杂度震荡\n比如扩容为2倍，缩容为一半，刚对原来长度的数组进行添加和删除，每次添加设删除的复杂度都是O(n)\n解决方案：扩容*缩容！=1，原理：错开扩容和缩容的时机。")]),t._v(" "),s("h4",{attrs:{id:"双向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双向链表"}},[t._v("#")]),t._v(" 双向链表")]),t._v(" "),s("p",[t._v("提升链表的综合性能；\nfrist和last,两个方向寻找，效率更高；\nLinkedList")]),t._v(" "),s("ul",[s("li",[t._v("node(int index);如果index<size,从first开始找，否则从last开始找；")]),t._v(" "),s("li",[t._v("clear：如果只是清除first和last size=0就可以，在java中如果对象不被gc root对象指向的就会被回收；")])]),t._v(" "),s("p",[t._v("如果被调用了finlize就会被释放了；")]),t._v(" "),s("ul",[s("li",[t._v("add(int index,E element)\nnext pre\n特殊处理：pre==null first = node\n添加最后一个元素last处理\n一开始什么都没有，last ==nul")]),t._v(" "),s("li",[t._v("remove 考虑第一个和最后一个；")]),t._v(" "),s("li")]),t._v(" "),s("p",[t._v("缩容的时机：remove、clear")]),t._v(" "),s("h4",{attrs:{id:"双向链表和单向链表对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双向链表和单向链表对比"}},[t._v("#")]),t._v(" 双向链表和单向链表对比")]),t._v(" "),s("ul",[s("li",[t._v("删除操作:单向n/2;双向n/4")]),t._v(" "),s("li")]),t._v(" "),s("p",[t._v("动态数组：开辟和销毁内存空间的次数较少，但会造成内存空间的浪费（可以通过缩容来解决）\n双向链表：开辟和销毁内存空间的次数较多，但不会造成内存空间的浪费")]),t._v(" "),s("p",[t._v("如果频繁在头部和尾部添加删除操作，动态数组和双向链表都可以选择\n如果频繁在头部和尾部添加删除操作，建议选择双向链表\n如果频繁在任意位置添加删除操作，建议选择双向链\n如果频繁的查询操作，（随机访问操作），建议使用动态数组")]),t._v(" "),s("p",[t._v("如果有了双向链表，单向链表是否没有什么用处了？\n并非如此，在哈希表的设计中就用到了单向链表。原因在后面的哈希表中解析；")])])}),[],!1,null,null,null);a.default=r.exports}}]);